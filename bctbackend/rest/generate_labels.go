package rest

import (
	"bctbackend/algorithms"
	dberr "bctbackend/database/errors"
	"bctbackend/database/models"
	"bctbackend/database/queries"
	"bctbackend/pdf"
	"bctbackend/rest/failure_response"
	"database/sql"
	"errors"
	"fmt"
	"net/http"

	"log/slog"

	"github.com/gin-gonic/gin"
)

type Insets struct {
	Top    float64 `json:"top"`
	Bottom float64 `json:"bottom"`
	Left   float64 `json:"left"`
	Right  float64 `json:"right"`
}

type Layout struct {
	PaperWidth   float64 `json:"paperWidth"`
	PaperHeight  float64 `json:"paperHeight"`
	PaperMargins Insets  `json:"paperMargins"`
	Columns      int     `json:"columns"`
	Rows         int     `json:"rows"`
	LabelMargins Insets  `json:"labelMargins"`
	LabelPadding Insets  `json:"labelPadding"`
	FontSize     float64 `json:"fontSize"`
}

type GenerateLabelsPayload struct {
	Layout  Layout      `json:"layout"`
	ItemIds []models.Id `json:"itemIds"`
}

func GenerateLabels(context *gin.Context, configuration *Configuration, db *sql.DB, userId models.Id, roleId models.RoleId) {
	if !roleId.IsSeller() {
		slog.Error("GenerateLabels called with wrong role", "userId", userId, "roleId", roleId)
		failure_response.WrongRole(context, "Only sellers can generate labels")
		return
	}

	var payload GenerateLabelsPayload
	if err := context.ShouldBindJSON(&payload); err != nil {
		slog.Error("Failed to parse payload for GenerateLabels endpoint", "error", err)
		failure_response.InvalidRequest(context, "Failed to parse payload:"+err.Error())
		return
	}

	if len(payload.ItemIds) == 0 {
		slog.Error("GenerateLabels called with no items", "userId", userId)
		failure_response.MissingItems(context, "No items provided")
		return
	}

	itemTable, err := queries.GetItemsWithIds(db, payload.ItemIds)
	if err != nil {
		if errors.Is(err, dberr.ErrNoSuchItem) {
			failure_response.UnknownItem(context, err.Error())
			return
		}

		failure_response.Unknown(context, "Failed to fetch items: "+err.Error())
	}

	// Verify that all items belong to the active seller
	for _, item := range itemTable {
		if item.SellerID != userId {
			slog.Error("GenerateLabels called with items not owned by the seller", "itemId", item.ItemID, "userId", userId)
			failure_response.WrongSeller(context, "labels can only be generated by the owning seller")
			return
		}
	}

	labelData, err := collectLabelData(db, itemTable, payload.ItemIds)
	if err != nil {
		slog.Error("GenerateLabels failed to collect label data", "error", err)
		failure_response.Unknown(context, "Failed to collect label data: "+err.Error())
		return
	}

	settings, err := pdf.NewLayoutSettings(
		pdf.WithPaperSize(
			payload.Layout.PaperWidth,
			payload.Layout.PaperHeight,
		),
		pdf.WithPaperMargins(
			payload.Layout.PaperMargins.Top,
			payload.Layout.PaperMargins.Right,
			payload.Layout.PaperMargins.Bottom,
			payload.Layout.PaperMargins.Left,
		),
		pdf.WithGridSize(payload.Layout.Columns, payload.Layout.Rows),
		pdf.WithLabelMargins(
			payload.Layout.LabelMargins.Top,
			payload.Layout.LabelMargins.Right,
			payload.Layout.LabelMargins.Bottom,
			payload.Layout.LabelMargins.Left,
		),
		pdf.WithLabelPadding(
			payload.Layout.LabelPadding.Top,
			payload.Layout.LabelPadding.Right,
			payload.Layout.LabelPadding.Bottom,
			payload.Layout.LabelPadding.Left,
		),
		pdf.WithFontSize(payload.Layout.FontSize),
	)
	if err != nil {
		failure_response.InvalidLayout(context, "Failed to parse layout: "+err.Error())
		return
	}

	pdfConfiguration := pdf.Configuration{
		FontDirectory: configuration.FontDirectory,
		FontFilename:  configuration.FontFilename,
		FontFamily:    configuration.FontFamily,
		BarcodeWidth:  configuration.BarcodeWidth,
		BarcodeHeight: configuration.BarcodeHeight,
	}
	builder, err := pdf.GeneratePdf(&pdfConfiguration, settings, labelData)
	if err != nil {
		slog.Error("Failed to generate PDF", "error", err)
		failure_response.InvalidRequest(context, "Failed to generate PDF: "+err.Error())
		return
	}

	buffer, err := builder.WriteToBuffer()
	if err != nil {
		slog.Error("Failed to write PDF to buffer", "error", err)
		failure_response.InvalidRequest(context, "Failed to write PDF to buffer: "+err.Error())
		return
	}

	if err := queries.UpdateFreezeStatusOfItems(db, payload.ItemIds, true); err != nil {
		slog.Error("Failed to freeze items", "error", err)
		failure_response.Unknown(context, "Failed to freeze items: "+err.Error())
		return
	}

	context.Header("Content-Disposition", "attachment; filename=labels.pdf")
	context.DataFromReader(
		http.StatusOK,
		int64(buffer.Len()),
		"application/pdf",
		buffer,
		map[string]string{"Content-Disposition": "attachment; filename=labels.pdf"},
	)
}

func collectLabelData(db *sql.DB, itemTable map[models.Id]*models.Item, itemIds []models.Id) ([]*pdf.LabelData, error) {
	createLabelData := func(itemId models.Id) (*pdf.LabelData, error) {
		item, ok := itemTable[itemId]
		if !ok {
			return nil, fmt.Errorf("bug: item with id %d not found; should never occur: this error should have be caught earlier", itemId)
		}

		categoryNameTable, err := queries.GetCategoryNameTable(db)
		if err != nil {
			return nil, err
		}

		return createLabelDataFromItem(categoryNameTable, item)
	}

	labelData, err := algorithms.MapError(itemIds, createLabelData)
	if err != nil {
		return nil, err
	}

	return labelData, nil
}

func createLabelDataFromItem(categoryNameTable map[models.Id]string, item *models.Item) (*pdf.LabelData, error) {
	barcode := fmt.Sprintf("%dx", item.ItemID)

	category, ok := categoryNameTable[item.CategoryID]
	if !ok {
		return nil, fmt.Errorf("unknown category id: %v", item.CategoryID)
	}

	labelData := &pdf.LabelData{
		BarcodeData:      barcode,
		Description:      item.Description,
		Category:         category,
		ItemIdentifier:   int(item.ItemID),
		PriceInCents:     int(item.PriceInCents),
		SellerIdentifier: int(item.SellerID),
		Charity:          item.Charity,
		Donation:         item.Donation,
	}

	return labelData, nil
}
